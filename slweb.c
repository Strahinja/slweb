/*
 *    slweb - Simple static webpage generator
 *    Copyright (C) 2020  Страхиња Радић
 *
 *    This program is free software: you can redistribute it and/or modify it
 *    under the terms of the GNU General Public License as published by the Free
 *    Software Foundation, either version 3 of the License, or (at your option)
 *    any later version.
 *
 *    This program is distributed in the hope that it will be useful, but
 *    WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 *    or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 *    for more details.
 *
 *    You should have received a copy of the GNU General Public License along
 *    with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 */

#include "defs.h"
#include <asm-generic/errno-base.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistr.h>

static size_t lineno = 0;
static size_t colno = 1;

int
version()
{
    printf("%s v%s\n", PROGRAMNAME, VERSION);
    return 0;
}

int
usage()
{
    printf("Usage: %s [-b|--body-only] [-d|--basedir <dir>] [-h|--help]"
        " [-v|--version] [filename]\n", PROGRAMNAME);
    return 0;
}

int
error(int code, uint8_t* fmt, ...)
{
    uint8_t    buf[BUFSIZE];
    va_list args;
    va_start(args, fmt);
    u8_vsnprintf(buf, sizeof(buf), (const char*)fmt, args);
    va_end(args);
    fprintf(stderr, "%s: %s", PROGRAMNAME, buf);
    return code;
}

int
warning(int code, uint8_t* fmt, ...)
{
    uint8_t    buf[BUFSIZE];
    va_list args;
    va_start(args, fmt);
    u8_vsnprintf(buf, sizeof(buf), (const char*)fmt, args);
    va_end(args);
    fprintf(stderr, "Warning: %s", buf);
    return code;
}

char*
substr(char* src, int start, int finish)
{
    int len = strlen(src);
    if (finish > len)
        finish = len;
    int substr_len = finish-start;
    if (substr_len < 0)
        substr_len = 0;
    char* result = (char*) calloc(substr_len+1, sizeof(char));
    if (!result)
        exit(error(ENOMEM, (uint8_t*)"Memory allocation failed (out of memory?)\n"));
    char* presult = result;

    for (int i = start; i < finish && *(src+i) != '\0'; i++)
    {
        *presult++ = *(src+i);
    }
    *presult = '\0';

    return result;
}

int
set_basedir(char* arg, char** basedir)
{
    if (*basedir)
        free(*basedir);

    if (strlen(arg) < 1)
    {
        return error(1, (uint8_t*)"--basedir: Argument required\n");
    }

    *basedir = (char*) calloc(strlen(arg)+1, sizeof(char));

    if (!*basedir) 
        return error(ENOMEM, (uint8_t*)"Memory allocation failed (out of memory?)\n");

    strcpy(*basedir, arg);

    return 0;
}

uint8_t*
init_string(uint8_t** str)
{
    if (!str || !*str)
        return NULL;

    *str[0] = '\0';

    return *str;
}

int
finish_and_print_token(uint8_t** token, uint8_t** ptoken, FILE* output)
{
    if (!token || !*token || !ptoken || !*ptoken)
        return 1;

    *ptoken[0] = '\0';
    fprintf(output, "%s", *token);
}

int
process_heading(uint8_t* token, FILE* output, UBYTE heading_level)
{
    if (!token || u8_strlen(token) < 1)
        warning(1, (uint8_t*)"Empty heading\n");

    fprintf(output, "<h%d>%s</h%d>",
            heading_level,
            token ? (char*)token : "",
            heading_level);

    return 0;
}

int
process_tag(uint8_t* token, FILE* output, BOOL end_tag)
{
    if (!token || u8_strlen(token) < 1)
        return warning(1, (uint8_t*)"No tag\n");

    if (!strcmp((char*)token, "made-by"))
    {
        fprintf(output, "<div id=\"made-by\">\n"
                "Generated by <a href=\"https://github.com/Strahinja/slweb\">"
                "slweb</a>\n"
                "© 2020 Strahinya Radich.\n"
                "</div><!--made-by-->\n");
    }
    else
        fprintf(output, "<%s%s>",
                end_tag ? (const char*)"/" : (const char*)"",
                token);

    return 0;
}

int
main(int argc, char** argv)
{
    char* arg;
    Command cmd = CMD_NONE;
    char* filename = NULL;
    BOOL body_only = FALSE;
    char* basedir = NULL;

    basedir = (char*) calloc(2, sizeof(char));
    if (!basedir)
        return error(ENOMEM, (uint8_t*)"Memory allocation failed (out of memory?)\n");
    basedir[0] = '.';

    while ((arg = *++argv))
    {
        if (*arg == '-')
        {
            arg++;
            char c = *arg++;
            int result;

            if (c == '-')
            {
                if (!strcmp(arg, "version"))
                {
                    cmd = CMD_VERSION;
                }
                else if (!strcmp(arg, "body-only"))
                {
                    arg += strlen("body-only");
                    body_only = TRUE;
                }
                else if (!strcmp(substr(arg, 0, strlen("basedir")), "basedir"))
                {
                    arg += strlen("basedir");
                    result = set_basedir(arg, &basedir);
                    if (result)
                        return result;
                }
                else if (!strcmp(arg, "help"))
                {
                    return usage();
                }
                else
                {
                    error(EINVAL, (uint8_t*)"Invalid argument: --%s\n", arg);
                    return usage();
                }
            }
            else
            {
                switch (c)
                {
                case 'b':
                    body_only = TRUE;
                    break;
                case 'd':
                    cmd = CMD_BASEDIR;
                    break;
                case 'h':
                    return usage();
                    break;
                case 'v':
                    cmd = CMD_VERSION;
                    break;
                default:
                    error(EINVAL, (uint8_t*)"Invalid argument: -%c\n", c);
                    return usage();
                }
            }
        }
        else
        {
            int result;

            if (cmd == CMD_BASEDIR)
            {
                result = set_basedir(arg, &basedir);
                if (result)
                    return result;
            }
            else
            {
                filename = arg;
            }
            cmd = CMD_NONE;
        }
    }

    if (cmd == CMD_BASEDIR)
        return error(1, (uint8_t*)"-d: Argument required\n");

    if (cmd == CMD_VERSION)
        return version();

    FILE* input = NULL;
    if (filename)
    {
        input = fopen(filename, "r");
        if (!input)
        {
            return error(ENOENT, (uint8_t*)"No such file: %s\n", filename);
        }
    }
    else
        input = stdin;

    uint8_t* line = (uint8_t*) calloc(BUFSIZE, sizeof(uint8_t));
    uint8_t* pline = NULL;
    size_t line_len = 0;
    uint8_t* token = (uint8_t*) calloc(BUFSIZE, sizeof(uint8_t));
    uint8_t* ptoken = NULL;
    size_t token_len = 0;
    USHORT state = ST_NONE;
    UBYTE heading_level = 0;
    BOOL end_tag = FALSE;
    BOOL first_line_in_doc = TRUE;
    BOOL previous_line_blank = FALSE;
    BOOL print_newline = FALSE;

    if (!line)
        return error(ENOMEM, (uint8_t*)"Memory allocation failed (out of memory?)\n");

    do
    {
        if (!fgets((char*)line, sizeof(char) * BUFSIZE, input))
            continue;

        uint8_t* eol = u8_strchr(line, (ucs4_t)'\n');
        if (eol)
            *eol = (uint8_t)'\0';

        lineno++;
        colno = 1;

        /*
         *fprintf(stderr, "=D: s:0x%X, hl:%d, et:%s, flid:%s, plb:%s \n", 
         *        state,
         *        heading_level,
         *        end_tag ? "T" : "F",
         *        first_line_in_doc ? "T" : "F",
         *        previous_line_blank ? "T" : "F");
         */

        line_len = u8_strlen(line);
        pline = line;
        ptoken = init_string(&token);

        do
        {
            switch (*pline)
            {
            case '-':
                if (colno == 1 
                        && !(state & ST_PRE)
                        && u8_strlen(pline) > 2
                        && !strcmp(substr((char*)pline, 0, 3), "---"))
                {
                    state ^= ST_YAML;

                    if (state & ST_YAML)
                        first_line_in_doc = FALSE;
                    else 
                        first_line_in_doc = TRUE;

                    pline += 3;
                    colno += 3;
                }
                else
                {
                    *ptoken++ = *pline++;
                    colno++;
                }
                break;
            case '`':
                if (colno == 1 
                        && u8_strlen(pline) > 2
                        && !strcmp(substr((char*)pline, 0, 3), "```"))
                {
                    state ^= ST_PRE;
                    
                    if (state & ST_PRE)
                        printf("<pre>");
                    else
                        printf("</pre>");
                    print_newline = TRUE;

                    pline += 3;
                    colno += 3;
                }
                else if (!(state & (ST_HEADING | ST_YAML | ST_PRE)))
                {
                    state ^= ST_CODE;

                    if (state & ST_CODE)
                    {
                        *ptoken = '\0';
                        u8_strncat(ptoken, (uint8_t*)"<code>", strlen("<code>"));
                        ptoken += strlen("<code>");
                    }
                    else
                    {
                        *ptoken = '\0';
                        u8_strncat(ptoken, (uint8_t*)"</code>", strlen("</code>"));
                        ptoken += strlen("</code>");
                    }

                    pline++;
                    colno++;
                }
                else
                {
                    *ptoken++ = *pline++;
                    colno++;
                }
                break;
            case '#':
                if (colno == 1
                        && !(state & (ST_PRE | ST_YAML)))
                {
                    state |= ST_HEADING;
                    heading_level = 1;
                    pline++;
                    colno++;
                }
                else if (state & ST_HEADING && *(pline-1) == '#')
                {
                    if (heading_level < MAX_HEADING_LEVEL)
                        heading_level++;
                    pline++;
                    colno++;
                }
                else {
                    *ptoken++ = *pline++;
                    colno++;
                }
                break;
            case ' ':
                if (u8_strlen(pline) == 2)
                {
                    if (*(pline+1) == ' ')
                    {
                        *ptoken = '\0';
                        u8_strncat(ptoken, (uint8_t*)"<br />", strlen("<br />"));
                        ptoken += strlen("<br />");
                        pline++;
                        colno++;
                    }
                    else
                        *ptoken++ = *pline;
                }
                else if (!(state & ST_HEADING
                        && *(pline-1) == '#'))
                    *ptoken++ = *pline;
                pline++;
                colno++;
                break;
            case '{':
                if (state & (ST_PRE | ST_YAML | ST_HEADING))
                {
                    *ptoken++ = *pline++;
                    colno++;
                    break;
                }

                state |= ST_TAG;
                if (token[0])
                    finish_and_print_token(&token, &ptoken, stdout);
                ptoken = init_string(&token);
                pline++;
                colno++;
                break;

            case '/':
                if (state & (ST_PRE | ST_YAML | ST_HEADING))
                {
                    *ptoken++ = *pline++;
                    colno++;
                    break;
                }

                if (state & ST_TAG)
                {
                    if (*(pline-1) != '{')
                        return error(1, (uint8_t*)"Character '/' not allowed here");

                    end_tag = TRUE;
                }
                else
                    *ptoken++ = *pline;

                pline++;
                colno++;
                break;

            case '}':
                if (state & (ST_PRE | ST_YAML | ST_HEADING))
                {
                    *ptoken++ = *pline++;
                    colno++;
                    break;
                }

                state &= ~ST_TAG;
                *ptoken = '\0';
                process_tag(token, stdout, end_tag);
                first_line_in_doc = FALSE;
                print_newline = TRUE;
                ptoken = init_string(&token);
                end_tag = FALSE;

                pline++;
                colno++;
                break;

            default:
                *ptoken++ = *pline++;
                colno++;
            }
        }
        while (pline && *pline);

        if (!(state & ST_YAML))
        {
            if (token[0])
            {
                if (colno != 2 && !(state & ST_PRE))
                    printf("\n");

                if (state & ST_HEADING)
                {
                    state &= ~ST_HEADING;
                    *ptoken = '\0';
                    process_heading(token, stdout, heading_level);
                    first_line_in_doc = FALSE;
                    ptoken = init_string(&token);
                    heading_level = 0;
                    print_newline = TRUE;
                }
                else {

                    if (first_line_in_doc || previous_line_blank
                            && !(state & ST_PRE))
                    {
                        printf("<p>");
                        first_line_in_doc = FALSE;
                        state |= ST_PARA_OPEN;
                    }
                    finish_and_print_token(&token, &ptoken, stdout);
                    print_newline = state & (ST_PRE | ST_CODE);
                }
                previous_line_blank = FALSE;
            }
            else if (colno == 2)
            {
                if (!previous_line_blank 
                        && (state & ST_PARA_OPEN)
                        && !(state & ST_PRE))
                {
                    printf("</p>\n");
                    print_newline = FALSE;
                    state &= ~ST_PARA_OPEN;
                }
                previous_line_blank = TRUE;
            }
            else
                previous_line_blank = FALSE;

            if (print_newline
                    || (state & ST_PRE))
            {
                printf("\n");
                print_newline = FALSE;
            }

        }

        ptoken = init_string(&token);

    }
    while (!feof(input));

    free(line);

    return 0;
}

